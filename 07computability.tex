\chapter{計算可能性(Computability)}
計算可能性とは，「特定の問題に解を与える手続き(プログラム)は作れるか?」
という問に応える理論．

問題が完全に固定ならば，計算可能性は自明である．\footnote{printf(\"答え
\"); でOK}

「将棋は先手必勝か」というような問に対してはどうか．これも問題が固定であ
り，計算
可能であると言える．この問に対する答えは，[Yes/No]の2通りしかない．従っ
て，Yesを出力するプログラムと，Noを出力するプログラムを作成すれば，その
どちらかは「特定の問題に解を与える手続き(プログラム)」である．

更に，入力の種類が有限ならば，これも計算可能である．何故ならば，出力は入
力によって決まるので，入出力の対応は可算無限種(enumerable)．従って，それ
らの入出力1ペアずつに対応するプログラムを上記のように作成することができ，結
局「問題が完全に固定」ということができる．

ところが，入力が無限種の場合はそうはいかない，正解か否の判定は，有限の手
続きで終わらない．

従って，\mystrong{無限種の入力を持つ問題だけに計算可能性を考える意味があ
る．}

まず計算可能性を考える前に，本当に解けない問題があることを証明しよう．

\begin{mytheorem} \label{theo:07cannot_solve}
 ある問題に対して，それを解くことができるプログラムが必ずしも存
 在しない．
\end{mytheorem}

\begin{myproof}{定理\ref{theo:07cannot_solve}の証明}
このことは，表\ref{tb:07ある問題に対して，それを解くことができるプログラ
 ムが必ずしも存在しないことを証明する表}
 によって証明できる．(対角線論法) \footnotemark
\end{myproof}
\footnotetext{この証明は追えませんでした．．．分かる方がいましたらご連絡
でもおねがいします．}
 

\begin{table}
 \caption{ある問題に対して，それを解くことができるプログラムが必ずしも存
 在しないことを証明する表}
 \begin{center}
  \begin{tabular}{c|c|c|c|c|c|c|c}
   \hline
   プログラム＼入力 &0&1&2&3&4&5&$\cdots$ \\
    \hline \hline
   0&3&7&9&4&1&8&$\cdots$\\ \hline
   1&5&0&4&9&2&3&$\cdots$\\ \hline
   2&2&1&3&5&6&4&$\cdots$\\ \hline
   3&5&1&9&6&1&3&$\cdots$\\ \hline
   $\cdots$&&&&&&\\ \hline
  \end{tabular}
  \label{tb:07ある問題に対して，それを解くことができるプログラムが必ずしも存在しないことを証明する表}
 \end{center}
\end{table}


記述可能な仕様は可算集合．

問題となるのは，
記述できる問題仕様で計算できないものがあるか
意味のある仕様の問題で計算できないものがあるか

\section{帰納的可算集合(Recursively enumerable set)}
\mystrong{帰納的可算集合(Recursively enumerable set)}は，次のよう定義で
きる．

\[
 帰納的可算集合 \Leftrightarrow 帰納的関数の値域になっている集合 \footnote{帰納的関数とTMは同じ能力を持っているので，TMで受理できる言語は帰納的可算
である．}
\]

帰納的可算集合は，要素を順に数え上げる(enumerate)ことができ
る．\footnote{機能関数が順序付けられる性質のものだったので，その出力も入
力と同じ順番に並べられる．}

帰納的可算集合を\mystrong{計算可能}であるという．何故ならば，帰納的可算
集合の要素であれば，順に数え上げていくことで，有限の手間で確かに要素であ
ることがわかるから．
\footnote{要素でないことが有限の手間でわかるとは言っていない．}
\footnote{逆に，機能的でない可算集合では，ある値がそ
の集合の中にあるのか照合する方法を与えられない．}


\section{ゲーデル関数(Goedel function)}
関数$G: \N ^m \rightarrow \N$が1対1関数の時，すなわち，
\[
G(x_1, \cdots , x_m) = G(y_1, \cdots , y_m) \Leftrightarrow x_1 = y_1 ,
\, x_2 = y_2 , \, \cdots , x_m = y_m
\]
であるとき，$G$は$x_1, x_2, \cdots , x_m$をエンコードする関数とみなせる．

更にこのような$G$に対して，
\[
 G_i ( G ( x_1 , \cdots , x_m)) = x_i
\]
なる関数$G_1 , \cdots , G_m$があれば，これらでデコードすることができる．

$G$および$G_1, \cdots , G_m$が原始帰納的関数であるとき，$G$を\mystrong{ゲーデル関
数}，$G_1 , \cdots , G_m$を\mystrong{ゲーデル逆関数}と呼び，$G(x_1 ,
\cdots , x_m)$を$x_1 , \cdots , x_m$の\mystrong{ゲーデル数}と呼ぶ．

\begin{myexample}{ゲーデル関数の例}
 \[
  G(x_1 , \cdots , x_m) = \Pi^{m}_{k = 1} p_{k} ^{x_k}
 \]
 ただし$p_k$は$k$番目の素数．この場合，$G_i$は素因数分解によって求めるこ
 とができる．
\end{myexample}

ゲーデル関数を使って自然数の並びをエンコードして扱える．更に，並びの長さ
を任意長に拡張することも可能．従って，任意の記号列を自然数にエンコードし
て扱うことができる．


\section{プログラムの停止性判定}
プログラムをエンコードしたものと，それに対する入力データを入力して，その
プログラムがその入力データを取り込んだとき，実行を終えることができるか否
か．これを判断するプログラムが，停止性判定をするプログラムであ
る．\footnote{TMに対する万能TMみたいなものですね．}

これがあると超便利であるが，残念ながらそれは存在しない．

\begin{myproof}{プログラムの停止性を判断するプログラムが存在しないことの
 証明}
背理法による．

 まず，停止性判断をするプログラムの存在を仮定する．このプロ
 グラムからは，サブルーチンとして$stops(p, d)$を切り分けることができるは
 ず．ただし，$p$
 は対象プログラムをエンコードしたもの，$d$は対象プログラムに与える入力デー
 タ．また，その返り値は真偽値．

これを使って，
 \[
  if ( stops(p,d) ) then 無限ループ else 停止
 \]
というプログラムを作ることができる．このプログラムをエンコードしたものを
 $p_0$とする．

この$p_0$を引数に，$stops(p_0, p_0)$を呼んだら結果はどうなるかを考えてみ
 る．

\begin{description}

 \item[真を返す] 実際の実行を考えると，
            \[
            if (stops(p, d)) then 無限ループ   where p = p_0 d = p_0
            \]
            無限ループするはず．従って矛盾．
 \item[偽を返す] 実際の実行を考えると，
            \[
            if (stops(p, d)) then 無限ループ then 停止  where p = p_0 d = p_0
            \]
            停止するはず．従って矛盾．
\end{description}
どちらの場合でも矛盾するので，背理法の仮定が誤りであったことが言える．
\end{myproof}


\section{様々な停止性判定}
いま，停止性判定をするプログラムは作れないと証明したばかりだが，実は
「一般のプログラムの停止性を判定するプログラム」は作れないとしか言っていな
い．

特定のプログラムに対しては，それの停止性判定をするプログラムが作れる．

\begin{description}
 \item[] 
 停止することを意図して作ったプログラムは，実際に実行することでわかる．
 \item[nステップ以内に停止するか]
            エミュレータを作って$n$ステップ実行すればよい．
            \[
            stops_in_steps(p, d, n)
            \]
            というプログラムは作れる．
\end{description}


\section{停止性が計算不能であることの利用}
「プログラムがいつでもゼロを返す」の判定，つまり，
\[
always_zero(p)
\]
のようなものはできない．

プログラム$p$とデータ$d$に対して
\[
stops\_m\_steps\_pd (n) = stops\_in\_steps(p,d,n) \footnote{プログラムの世界
ではカリー化といいます．}
\]
を構成することができる(部分評価, partial evaluation)．これを使うと，
\[
stops(p, d) = ! always\_zero(code(p,d))
\]
ただし，$code(p,d)$は$stops\_in\_steps\_pd$をつくるコンパイラ

$always\_zero(p)$が作れるなら，$stops(p,d)$が作れてしまう．

\mystrong{$always\_zero$は作れない}このような論法で計算不能性を示すこと
が非常に多い．
