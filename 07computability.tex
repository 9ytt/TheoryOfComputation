\chapter{計算可能性(Computability)}
計算可能性とは，「特定の問題に解を与える手続き(プログラム)は作れるか?」
という問に応える理論．

問題が完全に固定ならば，計算可能性は自明である．\footnote{printf(\"答え
\"); でOK}

「将棋は先手必勝か」というような問に対してはどうか．これも問題が固定であ
り，計算
可能であると言える．この問に対する答えは，[Yes/No]の2通りしかない．従っ
て，Yesを出力するプログラムと，Noを出力するプログラムを作成すれば，その
どちらかは「特定の問題に解を与える手続き(プログラム)」である．

更に，入力の種類が有限ならば，これも計算可能である．何故ならば，出力は入
力によって決まるので，入出力の対応は可算無限種(enumerable)．従って，それ
らの入出力1ペアずつに対応するプログラムを上記のように作成することができ，結
局「問題が完全に固定」ということができる．

ところが，入力が無限種の場合はそうはいかない，正解か否の判定は，有限の手
続きで終わらない．

従って，\mystrong{無限種の入力を持つ問題だけに計算可能性を考える意味があ
る．}


\section{計算可能でない問題}

まず計算可能性を考える前に，本当に解けない問題があることを証明しよう．

\begin{mytheorem} \label{theo:07cannot_solve}
 ある問題に対して，それを解くことができるプログラムが必ずしも存
 在しない．
\end{mytheorem}

\begin{myproof}{定理\ref{theo:07cannot_solve}の証明}
このことは，表\ref{tb:07cannot_solve}
 によって証明できる．(対角線論法) \footnotemark
\end{myproof}
\footnotetext{この証明は追えませんでした．．．分かる方がいましたらご連絡
でもおねがいします．}
 

\begin{table}
 \caption{ある問題に対して，それを解くことができるプログラムが必ずしも存
 在しないことを証明する表}
 \begin{center}
  \begin{tabular}{c|c|c|c|c|c|c|c}
   \hline
   プログラム＼入力 &0&1&2&3&4&5&$\cdots$ \\
    \hline \hline
   0&3&7&9&4&1&8&$\cdots$\\ \hline
   1&5&0&4&9&2&3&$\cdots$\\ \hline
   2&2&1&3&5&6&4&$\cdots$\\ \hline
   3&5&1&9&6&1&3&$\cdots$\\ \hline
   $\cdots$&&&&&&\\ \hline
  \end{tabular}
  \label{tb:07cannot_solve}
 \end{center}
\end{table}

解けない問題があることはわかった．ここで興味があるのは，
「記述できる問題仕様で計算できないものがあるか」，もっと言えば，「意味のある仕様の問題で計算できないものがあるか」
ということである．

以下では，この問に対する答えを導くべく，いくつかの理論を学んでいく．


\section{帰納的可算集合(Recursively enumerable set)}
\mystrong{帰納的可算集合(Recursively enumerable set)}は，次のよう定義で
きる．

\[
 帰納的可算集合 \Leftrightarrow 帰納的関数の値域になっている集合 \footnote{帰納的関数とTMは同じ能力を持っているので，TMで受理できる言語は帰納的可算
である．}
\]

帰納的可算集合は，要素を順に数え上げる(enumerate)ことができ
る．\footnote{帰納関数が順序付けられる性質のものだったので，その出力も入
力と同じ順番に並べられる．}

帰納的可算集合を\mystrong{計算可能}であるという．何故ならば，帰納的可算
集合の要素であれば，順に数え上げていくことで，有限の手間で確かに要素であ
ることがわかるから．
\footnote{要素でないことが有限の手間でわかるとは言っていない．}
\footnote{逆に，帰納的でない可算集合では，ある値がそ
の集合の中にあるのか照合する方法を与えられない．}


\section{ゲーデル関数(Goedel function)}
関数$G: \N ^m \rightarrow \N$が1対1関数の時，すなわち，
\[
G(x_1, \cdots , x_m) = G(y_1, \cdots , y_m) \Leftrightarrow x_1 = y_1 ,
\, x_2 = y_2 , \, \cdots , x_m = y_m
\]
であるとき，$G$は$x_1, x_2, \cdots , x_m$をエンコードする関数とみなせる．

更にこのような$G$に対して，
\[
 G_i ( G ( x_1 , \cdots , x_m)) = x_i
\]
なる関数$G_1 , \cdots , G_m$があれば，これらでデコードすることができる．

$G$および$G_1, \cdots , G_m$が原始帰納的関数であるとき，$G$を\mystrong{ゲーデル関
数}，$G_1 , \cdots , G_m$を\mystrong{ゲーデル逆関数}と呼び，$G(x_1 ,
\cdots , x_m)$を$x_1 , \cdots , x_m$の\mystrong{ゲーデル数}と呼ぶ．

\begin{myexample}{ゲーデル関数の例}
 \[
  G(x_1 , \cdots , x_m) = \Pi^{m}_{k = 1} p_{k} ^{x_k}
 \]
 ただし$p_k$は$k$番目の素数．この場合，$G_i$は素因数分解によって求めるこ
 とができる．
\end{myexample}

ゲーデル関数を使って自然数の並びをエンコードして扱える．更に，並びの長さ
を任意長に拡張することも可能．従って，任意の記号列を自然数にエンコードし
て扱うことができる．


\section{プログラムの停止性判定} 
プログラムをエンコードしたものと，それに対する入力データを入力して，その
プログラムがその入力データを取り込んだとき，実行を終えることができるか否
か．これを判断するプログラムが，停止性判定をするプログラムであ
る．\footnote{TMに対する万能TMみたいなものですね．}

これがあると超便利であるが，残念ながらそれは存在しない．

\begin{myproof}{プログラムの停止性を判断するプログラムが存在しないことの
 証明}
\label{proof:07プログラムの停止性判定}
背理法による．

 まず，停止性判断をするプログラム$P(p,d)$の存在を仮定する．
 ただし，$p$
 は対象プログラムをエンコードしたもの，$d$は対象プログラムに与える入力デー
 タ．
 
$P$からは，サブルーチンとして$stops(p, d)$を切り分けることができるは
 ず(真偽値を帰り値として持つ)．

このもし本当に$P$が存在すれば，そのサブルーチン$stops(p, d)$を使って，
 \[
  if \hspace{1ex}( stops(p,d) )\hspace{1ex} then \hspace{1ex}無限ループ \hspace{1ex}else \hspace{1ex}停止
 \]
というプログラムを作ることができる．このプログラムをエンコードしたものを
 $p_0$とする．$p_0$は$p, d$を引数に取るので，$p_0 (p, d)$と表記できる．
このプログラムを$p_0(p_0, p_0)$と呼び出すことを考えよう($d = p_0$と
 は，$p_0$をエンコードしたもの
を入力データに使うということ)．これは，実際
 \[
  if \hspace{1ex}( stops(p_0,p_0) )\hspace{1ex} then \hspace{1ex}無限ループ \hspace{1ex}else \hspace{1ex}停止
 \]
というプログラム$p_1$を実行することに対応する($p_1 = p_0(p_0, p_0)$)．

いま，$p_1$のif-statementの
 test文，$stops(p_0,p_0)$の返り値について場合分けする．

\begin{description}
 \item[真を返す] \mbox{} \\
            $stops(p_0,d_0)$が真を返すとは，「プログラム$p_0$にデータ
            $p_0$を与えると，$p_0$の実行は止まる」ということ．

            ところ
            で，$p_1 = p_0 (p_0, p_0)$を呼び出すことを先程から考えている
            が，この呼出しも，「プログラム$p_0$にデータ$p_0$を与える」こ
            とを考えている．

            しかし，この呼出しによってできたプログラム
            $p_1$をよく見ると，$stops(p_0,d_0)$が真を返すときは，無限ルー
            プに陥るような仕様になっている．従って，矛盾が生じている．

 \item[偽を返す] \mbox{} \\
            同様に，矛盾．
\end{description}
どちらの場合でも矛盾するので，背理法の仮定が誤りであったことが言える．
\end{myproof}


\section{様々な停止性判定}
いま，停止性判定をするプログラムは作れないと証明したばかりだが，実は
「一般のプログラムの停止性を判定するプログラム」は作れないとしか言っていな
い．

特定の制約条件を与えると，プログラムの停止性判定をするプログラムが作れる．
ここでは，そのうちの1つの例について指摘する．

\begin{myexample}{「プログラムが$n$ステップ以内に停止するか」を判定するプ
 ログラム}
 停止することを意図して作ったプログラムは，実際に実行することでわかる．
 ここでは，エミュレータ\footnotemark を作って$n$ステップ実行すればよい．このエミュレー
 タは，
 \[
 stops\_in\_steps(p, d, n)
 \]
 のような形式を持つ．ただし，$p$は判定対象のプログラム，$d$は$p$に与える
 入力，$n$はステップ数で，$stops\_in\_steps$は真偽値を返り値に持つ．
\end{myexample}
\footnotetext{万能TMを想像しても良いですが，ここでは
\[
 停止判定対象のプログラム=私たちが組むようなプログラム，\hspace{2zw}エミュ
 レータ=プログラムを走らせるOS
 \]
とでも考えると，現実に則した理解ができると思います．
}
この例で出てきた$stops\_in\_steps(p, d, n)$関数は，次の節でも出
てくるので注意．

\section{「停止性が計算不能である」理論の利用}
証明\ref{proof:07プログラムの停止性判定}で示した，「プログラムの停止性判定を
するプログラムは作れない」という定理を利用して，他の問題の計算可能性を論
じることがよくある．ここでは，その一つの例を見てみる．

\begin{myproof}{「プログラムがいつでもゼロを返す」の判定は計算不可能}
「プログラムがいつでもゼロを返す」かどうかを判定するようなプログラムは作
 成できない．すなわち，
\[
always\_zero(p)
\]
のような関数は作成できないということを背理法で示す．

$stops\_in\_steps$関数の存在に関しては，証明\ref{proof:07プログラムの停止性
 判定}の脚注で触れた．いま，
プログラム$p$とデータ$d$に対して
\[
stops\_in\_steps\_pd (n) = stops\_in\_steps(p,d,n) 
\]
を構成することができる($stops\_in\_steps$関数に対する部分評価, partial evaluation)\footnotemark．

もし$always\_zero(p)$関数が存在可能(計算可能)だと仮定するな
 ら，$stops(p,d)$関数を
\[
stops(p, d) = !always\_zero(stops\_in\_steps\_pd (n))
\]
のように構成することができる．しかし，$stops(p,d)$の計算不可能性は，証明
 \ref{proof:07プログラムの停止性判定}にて示した．従って矛盾であり，背理
 法の仮定が誤りであったと言える．
\end{myproof}
\footnotetext{プログラムの世界
ではカリー化ともいいます．}
